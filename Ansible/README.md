# Ansible

## Overview

Ansible is a powerful automation tool used for various purposes such as automation, change management, provisioning, and orchestration. It stands out for its simplicity, as it does not require agents, databases, complex setups, or residual software on target machines.

## Key Features

- **Agentless:** Target machines and services are accessed using SSH, WinRM, and API.
- **No Database:** Configuration data is stored in YAML, INI, and text files.
- **Simple Setup:** Ansible is implemented as a Python library.
- **Idempotent:** Ansible ensures that the desired state is achieved without unnecessary changes.

## Usage

### Ad-hoc Commands

Execute single commands on the command line:

```bash
ansible webservers -m ping -i inventory
ansible web01 -m ansible.builtin.yum -a "name=httpd state=present" -i inventory --become
```

### Playbooks

Define configurations using playbooks, specifying hosts, tasks, modules, and options:

- Global Area: Hosts and tasks.
- Second Level: Module name.
- Third Level: Module options.

Run playbooks with:

```bash
ansible-playbook -i inventory playbook.yaml
```

Options:

- `-C`: Dry run (recommended before actual run).
- `-v`: Verbose mode for debugging (up to 4 "v").

### Ansible Config Order

1. **ANSIBLE_CONFIG:** Environment variable, if set.
2. **ansible.cfg:** In the current directory.
3. **~/.ansible.cfg:** Hidden file in the home directory.
4. **/etc/ansible/ansible.cfg:** Global file.

### Ansible Config Settings

Basic settings in the global Ansible config file (`ansible.cfg`):

1. `force_color = False`: Turn off color.
2. `ask_pass = False`: Do not prompt for passwords; use keys.
3. `debug = False`: Enable debug mode.
4. `force = 5`: Control the number of servers turned on at a time.
5. `inventory = /etc/ansible/host`: Specify the inventory file.
6. `log_path =`: Store output in a log file.

### Ansible Variables

Places to define variables:

1. **Playbook:** Using `vars:`. Example: `http_port: 80`.
2. **Inventory Based:** Define variables outside the playbook in group_vars, host_vars, etc.
3. **Roles:** Include variables from files in the playbook.
4. **Ansible Variable Order:** command line (less use) > playbook vars > host_vars > group_vars > group_vars/all 

### Fact Variables

Fact variables are automatically collected by Ansible during the execution of playbooks. These variables provide information about the target system, helping you make decisions and customize tasks based on the system's characteristics. Here are some examples:

1. `ansible_os_family`: Represents the OS family, such as RedHat or Debian.
2. `ansible_processor_cores`: Indicates the number of CPU cores on the target machine.
3. `ansible_kernel`: Shows the kernel version running on the system.
4. `ansible_devices`: Provides information about connected storage devices.
5. `ansible_default_ipv4`: Contains details about the default IPv4 network interface.
6. `ansible_architecture`: Specifies whether the system architecture is 64-bit or 32-bit.

### Storing Variables

Ansible allows you to store variables at different stages:

1. **Module Execution:** Variables can be created and modified during playbook execution using various Ansible modules. The output of these modules is often stored as variables.

2. **Return Output:** The output generated by Ansible modules can be stored as variables. These variables can be accessed and utilized later in the playbook.

3. **Use Variable:** Variables can be used in various ways, such as in conditions, loops, or for printing information. They add flexibility to playbooks and allow for dynamic behavior.

### Condition and Loop

- **Conditioning:** Use the `when` keyword in a module to apply conditions. For example, `when: ansible_distribution == "CentOS"` will execute a task only on CentOS machines.

- **Looping:** Use the `loop` keyword in a module to perform tasks iteratively. The loop contains an `item` variable representing the current iteration. Access the loop's items using `"{{ item }}"`.

### File, Copy, and Template Modules

Ansible provides modules for handling files, directories, and templates:

1. **File Module:** The `file` module is used to set attributes of files, create or remove directories, and more.

2. **Copy Module:** The `copy` module is employed to copy files from the local machine to remote hosts. It supports recursive copying.

3. **Template Module:** The `template` module allows you to use Jinja2 templates to dynamically generate files before copying them to the target system.

### Handlers

Handlers are special tasks in Ansible that are only run when notified by other tasks. They are typically used to restart services or perform similar actions only when changes have been made.

In your playbook, you can notify a handler using the `notify` keyword:

```yaml
tasks:
  - name: Ensure a configuration file is present
    copy:
      src: /path/to/config/file
      dest: /etc/config/file
    notify: Restart Service

handlers:
  - name: Restart Service
    service:
      name: myservice
      state: restarted
```

In this example, if the configuration file is copied, the handler "Restart Service" will be notified and execute the task to restart the service.

### Roles
Roles in Ansible provide a way to organize and structure your playbooks, making them more modular, reusable, and maintainable. A role is essentially a collection of tasks, variables, files, templates, and other Ansible artifacts organized in a predefined directory structure.

#### Directory Structure

A typical Ansible role directory structure looks like this:

```
my_role/
├── defaults/
│   └── main.yml
├── files/
├── handlers/
│   └── main.yml
├── meta/
│   └── main.yml
├── tasks/
│   └── main.yml
├── templates/
├── tests/
│   ├── inventory
│   └── test.yml
├── vars/
│   └── main.yml
└── README.md
```

- **defaults:** Default variables for the role.
- **files:** Static files that can be copied to the target machines.
- **handlers:** Handlers, which are notified by tasks and can be used to restart services, etc.
- **meta:** Metadata for the role, including dependencies.
- **tasks:** Main tasks for the role.
- **templates:** Jinja2 templates used by tasks.
- **tests:** Testing-related files, such as inventory and test playbooks.
- **vars:** Other variable files for the role.

#### Creating a Role

You can create a new role using the `ansible-galaxy` command:

```bash
ansible-galaxy init my_role
```

This will create the directory structure and initial files for your role.

#### Using a Role in a Playbook

To use a role in a playbook, you include it under the `roles` section:

```yaml
- name: My Playbook with a Role
  hosts: servers
  roles:
    - my_role
```

#### Role Dependencies

Roles can depend on other roles, and these dependencies are specified in the `meta/main.yml` file within the role:

```yaml
dependencies:
  - { role: username.role_name, some_variable: 'Hello' }
```

#### Benefits of Roles

1. **Reusability:** Roles can be reused across different playbooks and projects.
2. **Modularity:** Each role encapsulates a specific set of functionalities, promoting modular design.
3. **Readability:** The directory structure and separation of concerns make playbooks more readable and maintainable.

Roles enhance Ansible's capabilities by promoting best practices in playbook organization and enabling collaborative development and sharing of roles through Ansible Galaxy.